--- src/applet.c	2024-01-19 11:42:17.000000000 +0100
+++ src/applet.c.patched	2025-11-08 16:07:48.753424273 +0100
@@ -2008,6 +2008,59 @@
 
 /*****************************************************************************/
 
+gboolean
+is_dark_theme(void)
+{
+	GtkSettings *settings = gtk_settings_get_default();
+	gchar *theme_name = NULL;
+	g_object_get(settings, "gtk-theme-name", &theme_name, NULL);
+
+	gboolean is_dark = FALSE;
+
+	if (theme_name) {
+		gchar *lower = g_ascii_strdown(theme_name, -1);
+		if (strstr(lower, "dark") || strstr(lower, "night"))
+			is_dark = TRUE;
+
+		g_free(lower);
+		g_free(theme_name);
+	}
+
+	return is_dark;
+}
+
+static void
+gdk_pixbuf_tint(GdkPixbuf *pixbuf)
+{
+	if (!pixbuf)
+		return;
+	
+	int w = gdk_pixbuf_get_width(pixbuf);
+	int h = gdk_pixbuf_get_height(pixbuf);
+	int rowstride = gdk_pixbuf_get_rowstride(pixbuf);
+	int n_channels = gdk_pixbuf_get_n_channels(pixbuf);
+	guchar *pixels = gdk_pixbuf_get_pixels(pixbuf);
+
+	for (int y = 0; y < h; y++) {
+		guchar *p = pixels + y * rowstride;
+		for (int x = 0; x < w; x++) {
+			if (n_channels >= 3) {
+				if (is_dark_theme()) {
+					p[0] = 255;
+					p[1] = 255;
+					p[2] = 255;
+				}
+				else {
+					p[0] = 46;
+					p[1] = 52;
+					p[2] = 54;
+				}
+			}
+			p += n_channels;
+		}
+	}
+}
+
 static void
 foo_set_icon (NMApplet *applet, guint32 layer, GdkPixbuf *pixbuf, const char *icon_name)
 {
@@ -2064,9 +2117,22 @@
 	} else
 		pixbuf = nma_icon_check_and_load ("nm-no-connection", applet);
 
+	gdk_pixbuf_tint(pixbuf);
 	gtk_status_icon_set_from_pixbuf (applet->status_icon, pixbuf);
 }
 
+static void
+on_theme_changed(GObject *settings, GParamSpec *pspec, gpointer user_data)
+{
+	NMApplet *applet = NM_APPLET(user_data);
+
+	if (applet->icon_layers[0])
+		gdk_pixbuf_tint(applet->icon_layers[0]);
+
+	gtk_status_icon_set_from_pixbuf(applet->status_icon,
+									applet->icon_layers[0]);
+}
+
 NMRemoteConnection *
 applet_get_exported_connection_for_device (NMDevice *device, NMApplet *applet)
 {
@@ -2200,7 +2266,7 @@
 	case NM_STATE_DISCONNECTED:
 		applet_do_notify (applet, _("Disconnected"),
 		                  _("The network connection has been disconnected."),
-		                  "nm-no-connection",
+		                  "nm-no-connection-symbolic",
 		                  PREF_DISABLE_DISCONNECTED_NOTIFICATIONS);
 		break;
 	default:
@@ -2357,7 +2423,11 @@
 	g_signal_connect (applet->nm_client, "notify::wwan-enabled",
 	                  G_CALLBACK (foo_wireless_enabled_changed_cb),
 	                  applet);
-
+	                  
+	GtkSettings *settings = gtk_settings_get_default();
+	g_signal_connect(settings, "notify::gtk-theme-name",
+                 G_CALLBACK(on_theme_changed), applet);
+	                  
 	/* Initialize permissions - the initial 'permission-changed' signal is emitted from NMClient constructor, and thus not caught */
 	for (perm = NM_CLIENT_PERMISSION_NONE + 1; perm <= NM_CLIENT_PERMISSION_LAST; perm++) {
 		applet->permissions[perm] = nm_client_get_permission_result (applet->nm_client, perm);
@@ -2637,11 +2707,11 @@
 	switch (state) {
 	case NM_STATE_UNKNOWN:
 	case NM_STATE_ASLEEP:
-		icon_name = "nm-no-connection";
+		icon_name = "nm-no-connection-symbolic";
 		dev_tip = _("Networking disabled");
 		break;
 	case NM_STATE_DISCONNECTED:
-		icon_name = "nm-no-connection";
+		icon_name = "nm-no-connection-symbolic";
 		dev_tip = _("No network connection");
 		break;
 	default:
@@ -3159,7 +3229,7 @@
 #ifdef WITH_APPINDICATOR
 	if (with_appindicator) {
 		applet->app_indicator = app_indicator_new ("nm-applet",
-		                                           "nm-no-connection",
+		                                           "nm-no-connection-symbolic",
 		                                           APP_INDICATOR_CATEGORY_SYSTEM_SERVICES);
 		if (!applet->app_indicator)
 			return FALSE;
